public class SAP {

	private Digraph G;
	private boolean[] vMarked, wMarked;
	private int[] vDistance, wDistance;
	
	// constructor takes a digraph (not necessarily a DAG)
	public SAP(Digraph G) {
		this.G =  G;
	}

	// length of shortest ancestral path between v and w; -1 if no such path
	public int length(int v, int w) {
		Queue<Integer> vq = new Queue<Integer>();
		vq.enqueue(v);
		Queue<Integer> wq = new Queue<Integer>();
		wq.enqueue(w);
		
		int[] res = solve(vq, wq);
		
		return res[0];
	}

	private int[] solve(Iterable<Integer> vList, Iterable<Integer> wList) {
		int[] result = new int[2];
		
		bfs(vList, vMarked, vDistance);
		bfs(wList, wMarked, wDistance);
		
		int minDistance = Integer.MAX_VALUE;
		int ancestral = -1;
		
		for (int i = 0; i < G.V(); i++) {
			if (vMarked[i] && wMarked[i]) {
				int temp = vDistance[i] + wDistance[i];
				if (temp < minDistance) {
					minDistance = temp;
					ancestral = i;
				}
			}
		}
		
		if (minDistance == Integer.MAX_VALUE)
			minDistance = -1;
		
		result[0] = minDistance;
		result[1] = ancestral;
		
		return result;
	}

	private void bfs(Iterable<Integer> list, boolean[] marked, int[] distance) {
		for (int i = 0; i < marked.length; i++) 
			marked[i] = false;
		Queue<Integer> queue = new Queue<Integer>();
		for (int v : list) {
			marked[v] = true;
			distance[v] = 0;
			queue.enqueue(v);
		}
		
		while (!queue.isEmpty()) {
			int v = queue.dequeue();
			for (int w : G.adj(v)) {
				if (!marked[w]) {
					marked[w] = true;
					distance[w] = distance[v] + 1;
					queue.enqueue(w);
				}
			}
		}
	}

	// a common ancestor of v and w that participates in a shortest ancestral
	// path; -1 if no such path
	public int ancestor(int v, int w) {
		Queue<Integer> vq = new Queue<Integer>();
		vq.enqueue(v);
		Queue<Integer> wq = new Queue<Integer>();
		wq.enqueue(w);
		
		int[] res = solve(vq, wq);
		
		return res[1];
	}

	// length of shortest ancestral path between any vertex in v and any vertex
	// in w; -1 if no such path
	public int length(Iterable<Integer> v, Iterable<Integer> w) {
		return -1;
	}

	// a common ancestor that participates in shortest ancestral path; -1 if no
	// such path
	public int ancestor(Iterable<Integer> v, Iterable<Integer> w) {
		return -1;
	}

	// do unit testing of this class
	public static void main(String[] args) {
	}
}