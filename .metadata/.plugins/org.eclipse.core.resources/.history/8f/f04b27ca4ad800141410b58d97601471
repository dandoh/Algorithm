import java.awt.Color;

public class SeamCarver {

	private Picture picture;
	private int END;
	private int[] dx = {-1, 0, 1};
	private int[] dy = {-1, 0, 1};

	// create a seam carver object based on the given picture
	public SeamCarver(Picture picture) {
		if (picture == null)
			throw new NullPointerException();
		this.picture = picture;
	}

	// current picture
	public Picture picture() {
		return picture;
	}

	// width of current picture
	public int width() {
		return picture.width();
	}

	// height of current picture
	public int height() {
		return picture.height();
	}

	// energy of pixel at column x and row y
	public double energy(int x, int y) {
		if (x < 0 || x > width() - 1 || y < 0 || y > height() - 1)
			throw new IndexOutOfBoundsException();

		if (x == 0 || x == width() - 1 || y == 0 || y == height() - 1)
			return 195075; // 255^2 + 255^2 + 255^2

		Color left = picture.get(x - 1, y);
		Color right = picture.get(x + 1, y);
		Color up = picture.get(x, y - 1);
		Color down = picture.get(x, y + 1);

		double Rx = square(left.getRed() - right.getRed());
		double Gx = square(left.getGreen() - right.getGreen());
		double Bx = square(left.getBlue() - right.getBlue());

		double Ry = square(up.getRed() - down.getRed());
		double Gy = square(up.getGreen() - down.getGreen());
		double By = square(up.getBlue() - down.getBlue());

		return Rx + Gx + Bx + Ry + Gy + By;
	}

	private int square(int x) {
		return x * x;
	}

	// sequence of indices for horizontal seam
	public int[] findHorizontalSeam() {

		int[] horiSeam = bfs(false);

		return horiSeam;
	}

	// sequence of indices for vertical seam
	public int[] findVerticalSeam() {

		int[] verSeam = bfs(true);

		return verSeam;
	}
	
	
	private int[] bfs(boolean isVertical) {
		if (isVertical) {
			int[] res = new int[height()];
			int[] parent = new int[width() * height() + 1];
			double[] distance = new double[width() * height() + 1];
			boolean[] onQueue = new boolean[width() * height() + 1];
			
			
			for (int i = 0; i < width() * height() + 1; i++) {
				distance[i] = Double.POSITIVE_INFINITY;
				onQueue[i] = false;
			}
			
			Queue<Integer> queue = new Queue<Integer>();
			for (int i = 0; i < width(); i++) {
				distance[i] = energy(x(i), y(i));
				onQueue[i] = true;
				queue.enqueue(i);
				parent[i] = -1;
			}
			
			while (!queue.isEmpty()) {
				int p = queue.dequeue();
				int x = x(p), y = y(p);
				
				if (y < height() - 1) {
					for (int i = 0; i < 3; i++) {
						int newX = x + dx[i];
						int newY = y + 1;
						if (newX < 0 || newX > width() - 1) 
							continue;
						int newP = newY * width() + newX;
						if (distance[newP] > distance[p] + energy(newX, newY)) {
							distance[newP] = distance[p] + energy(newX, newY);
							parent[newP] = p;
							if (!onQueue[newP]) 
								queue.enqueue(newP);
							onQueue[newP] = true;
						}
					}
				}
			}
			
			
		}
	}
	
	private int x(int id) { // column
		return id % width();
	}

	private int y(int id) { // row
		return id / width();
	}

	// remove horizontal seam from current picture
	public void removeHorizontalSeam(int[] seam) {
	}

	// remove vertical seam from current picture
	public void removeVerticalSeam(int[] seam) {
	}
}
