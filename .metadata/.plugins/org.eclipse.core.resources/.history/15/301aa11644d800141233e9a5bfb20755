import java.awt.Color;

public class SeamCarver {

	private Picture picture;
	private int END;
	private int[] downX = { -1, 0, 1 };
	private int[] downY = { -1, 0, 1 };

	// create a seam carver object based on the given picture
	public SeamCarver(Picture picture) {
		if (picture == null)
			throw new NullPointerException();
		this.picture = picture;
	}

	// current picture
	public Picture picture() {
		return picture;
	}

	// width of current picture
	public int width() {
		return picture.width();
	}

	// height of current picture
	public int height() {
		return picture.height();
	}

	// energy of pixel at column x and row y
	public double energy(int x, int y) {
		if (x < 0 || x > width() - 1 || y < 0 || y > height() - 1)
			throw new IndexOutOfBoundsException();

		if (x == 0 || x == width() - 1 || y == 0 || y == height() - 1)
			return 195075; // 255^2 + 255^2 + 255^2

		Color left = picture.get(x - 1, y);
		Color right = picture.get(x + 1, y);
		Color up = picture.get(x, y - 1);
		Color down = picture.get(x, y + 1);

		double Rx = square(left.getRed() - right.getRed());
		double Gx = square(left.getGreen() - right.getGreen());
		double Bx = square(left.getBlue() - right.getBlue());

		double Ry = square(up.getRed() - down.getRed());
		double Gy = square(up.getGreen() - down.getGreen());
		double By = square(up.getBlue() - down.getBlue());

		return Rx + Gx + Bx + Ry + Gy + By;
	}

	private int square(int x) {
		return x * x;
	}

	// sequence of indices for horizontal seam
	public int[] findHorizontalSeam() {

		int[] horiSeam = bfs(false);

		return horiSeam;
	}

	// sequence of indices for vertical seam
	public int[] findVerticalSeam() {

		int[] verSeam = bfs(true);

		return verSeam;
	}

	private int[] bfs(boolean isVertical) {

		END = width() * height();
		double[] distance = new double[width() * height() + 1];
		boolean[] inqueue = new boolean[width() * height() + 1];
		int[] parent = new int[width() * height() + 1];
		int[] res;
		if (isVertical)
			res = new int[height()];
		else
			res = new int[width()];

		for (int i = 0; i < width() * height(); i++) {
			distance[i] = Double.POSITIVE_INFINITY;
			inqueue[i] = false;
		}
		if (isVertical)
			for (int i = 0; i < width(); i++) {
				distance[i] = energy(x(i), y(i));
				parent[i] = -1;
			}
		else {
			for (int i = 0; i < height(); i++) {
				distance[i * width()] = energy(0, i);
				parent[i * width()] = -1;
			}
		}
		distance[END] = Double.POSITIVE_INFINITY;

		Queue<Integer> queue = new Queue<Integer>();
		if (isVertical)
			for (int i = 0; i < width(); i++) {
				queue.enqueue(i);
			}
		else
			for (int i = 0; i < height(); i++) {
				queue.enqueue(i * width());
			}

		while (queue.isEmpty()) {
			int p = queue.dequeue();
			int x = x(p);
			int y = y(p);

			if (isVertical) {
				if (y < height() - 1) {
					for (int i = 0; i < 3; i++) {
						int newX = x + downX[i];
						int newY = y + 1;
						if (newX < 0 || newX > width() - 1 || newY < 0
								|| newY > height() - 1)
							continue;

						int newP = (newY * width() + newX);
						if (distance[newP] > distance[p] + energy(newX, newY)) {
							distance[newP] = distance[p] + energy(newX, newY);
							parent[newP] = p;
							if (!inqueue[newP])
								queue.enqueue(newP);
							inqueue[newP] = true;
						}
					}
				} else {
					if (distance[END] > distance[p]) {
						distance[END] = distance[p];
						parent[END] = p;
					}
				}
			} else {
				if (x < width() - 1) {
					for (int i = 0; i < 3; i++) {
						int newX = x + 1;
						int newY = y + downY[i];
						if (newX < 0 || newX > width() - 1 || newY < 0
								|| newY > height() - 1)
							continue;

						int newP = (newY * width() + newX);
						if (distance[newP] > distance[p] + energy(newX, newY)) {
							distance[newP] = distance[p] + energy(newX, newY);
							parent[newP] = p;
							if (!inqueue[newP])
								queue.enqueue(newP);
							inqueue[newP] = true;
						}
					}
				} else {
					if (distance[END] > distance[p]) {
						distance[END] = distance[p];
						parent[END] = p;
					}
				}
			}
		}
		
		if (isVertical) {
			int i = END;
			while (parent[i] != -1) {
				i = parent[i];
				res[y(i)] = x(i); 
			}
		} else {
			int i = END;
			while (parent[i] != -1) {
				i = parent[i];
				res[x(i)] = y(i);
			}
		}
		
		return res;

	}

	private int x(int id) { // column
		return id % width();
	}

	private int y(int id) { // row
		return id / width();
	}

	// remove horizontal seam from current picture
	public void removeHorizontalSeam(int[] seam) {
	}

	// remove vertical seam from current picture
	public void removeVerticalSeam(int[] seam) {
	}
}
