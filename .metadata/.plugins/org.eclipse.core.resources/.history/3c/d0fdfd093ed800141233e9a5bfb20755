import java.awt.Color;

public class SeamCarver {

	private Picture picture;
	private int BOTTOM, RIGHT;
	private int[] downX = {-1, 0, 1};

	// create a seam carver object based on the given picture
	public SeamCarver(Picture picture) {
		if (picture == null)
			throw new NullPointerException();
		this.picture = picture;
	}

	// current picture
	public Picture picture() {
		return picture;
	}

	// width of current picture
	public int width() {
		return picture.width();
	}

	// height of current picture
	public int height() {
		return picture.height();
	}

	// energy of pixel at column x and row y
	public double energy(int x, int y) {
		if (x < 0 || x > width() - 1 || y < 0 || y > height() - 1)
			throw new IndexOutOfBoundsException();

		if (x == 0 || x == width() || y == 0 || y == height() - 1)
			return 195075; // 255^2 + 255^2 + 255^2

		Color left = picture.get(x - 1, y);
		Color right = picture.get(x + 1, y);
		Color up = picture.get(x, y - 1);
		Color down = picture.get(x, y + 1);

		double Rx = square(left.getRed() - right.getRed());
		double Gx = square(left.getGreen() - right.getGreen());
		double Bx = square(left.getBlue() - right.getBlue());

		double Ry = square(up.getRed() - down.getRed());
		double Gy = square(up.getGreen() - down.getGreen());
		double By = square(up.getBlue() - down.getBlue());

		return Rx + Gx + Bx + Ry + Gy + By;
	}

	private int square(int x) {
		return x * x;
	}

	// sequence of indices for horizontal seam
	public int[] findHorizontalSeam() {
	}

	// sequence of indices for vertical seam
	public int[] findVerticalSeam() {
		BOTTOM = width() * height();
		double[] distance = new double[width() * height() + 1];
		int[] verSeam = new int[height()];

		bfs(true, distance, verSeam);
	}

	private void bfs(boolean isVertical, double[] distance, int[] res) {
		if (isVertical) {
			
			int [] parrent = new int[distance.length];
			
			for (int i = 0; i < width() * height(); i++) {
				distance[i] = Double.POSITIVE_INFINITY;
			}
			
			for (int i = 0; i < width(); i++) {
				distance[i] = energy(x(i), y(i));
			}
			distance[BOTTOM] = Double.POSITIVE_INFINITY;
			
			Queue<Integer> queue = new Queue<Integer>();
			for (int i = 0; i < width(); i++) {
				queue.enqueue(i);
			}
			
			while (queue.isEmpty()) {
				int p = queue.dequeue();
				int x = x(p);
				int y = y(p);
				
				if (y < height() - 1) {
					for (int i = 0; i < 3; i++) {
						int newX = x + downX[i];
						int newY = y + 1;
						
						if (distance[newY * width() + newX] > distance[p] + energy(newX, newY)) {
							
						}
					}
				} else {
					
				}
			}
			
			
			
		}
	}
	
	private int x(int id) { // column
		return id % width();
	}

	private int y(int id) { // row
		return id / width();
	}

	// remove horizontal seam from current picture
	public void removeHorizontalSeam(int[] seam) {
	}

	// remove vertical seam from current picture
	public void removeVerticalSeam(int[] seam) {
	}
}
